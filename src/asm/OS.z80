;OS for boot ROM with bootcode and romcalls
;Copyright (C) 2023-2024  Tristan van de Weg & Marijn Vollenberg
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License along
;    with this program; if not, write to the Free Software Foundation, Inc.,
;    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

#define OSfile					;Some things in the include file don't need to be defined
#include "inc/z80.inc"			;Useful values

;--------------------------------
;Boot Code
;--------------------------------
Boot:
	;Set stack pointer to RAM
	ld hl,_StackTop				;Set stack pointer to correct place in RAM
	ld sp,hl					;
	
	;Set I/O
	ld a,_ModeSetFlag|_PortAOutput|_PortBOutput|_PortClOutput|_PortCuOutput|_PortCuAMode0|_PortClBMode0			;Set IO1 ports A, B and C to mode 0 output
	out (_IO1Cmd),a																								;
	ld a,_ModeSetFlag|_PortAInput|_PortBInput|_PortClOutput|_PortCuOutput|_PortCuAMode0|_PortClBMode0			;Set IO2 ports A and B to mode 0 input, set port C to mode 0 output
	out (_IO2Cmd),a																								;

	;Start display
	call _DisplayInit
	call _DisplayOn
	call _ClearDisp
	call _WriteVRAM

	ld hl, _fontSmall			;Set the font
	ld (_CurFont), hl			;

	;Attempt to start a program from external memory
	in a, (_ExtIO1)				;Check for program start byte in slot 1
	cp a, _ExtIndPrgm			;
	jp z, _ExtMem				;Jump to program if there is one

	in a, (_ExtIO4)				;Check for program start byte in slot 2
	cp a, _ExtIndPrgm			;
	jp z, _ExtMem				;Jump to program if there is one

	;Print error message
	ld hl,strBootError			;Print Error message if there is no program
	call _PrintS				;

	halt						;Halt the CPU if no program is found

_Exit:							;Print program finished message and halt when a program has finished
	call _ClearDisp
	ld hl,strProgramExit
	call _PrintS
	halt

strProgramExit:					;Successful execution of program
	.db "Program finished, halting",0

strBootError:					;No programs found
	;.db "No valid program found",0
	.db " H E L L O",0

;--------------------------------
;ROM Calls
;--------------------------------
.echo "Subroutine addresses:"

;--------------------------------
;Printing

_PrintS:						;Address of string to print in hl, string must end in 0
.echo "PrintS ",_PrintS;Address of the subroutine
	;hl	= String address counter
	;a	= Byte to print

	ld a,(hl)

	cp a,0						;Check for end byte
	jr z, _WriteVRAM			;If a = 0, write vram and then return

	push hl						;Preserve hl in the stack
	call _PrintB				;Print the byte
	pop hl						;Retrieve hl from the stack

	inc hl						;Go to the next byte
	jr _PrintS



_PrintB:						;Byte to print in a
.echo "PrintB ",_PrintB;Address of the subroutine
	;hl	= Character sprite address
	;a	= ASCII byte / sprite address offset
	;bc	= Sprite address offset / sprite data
	;d	= Width
	;e	= Height

	push af
	ld hl, (_CurFont)			;Set HL to the current font address
	ld a, (hl)					;The first byte of the font is the font size (bit 0-3=height, bit 4-7=width)
	ld e, %11110000				;Get the sprite width
	and e						;
	srl a						;Shift the width into place
	srl a
	srl a
	srl a
	ld d, a						;Sprite width in d TODO: maybe increment d and e
	ld a, (hl)
	ld e, %00001111
	and e
	ld e, a						;Sprite height in e

	ld a, (_CursorX)			;Copy CursorX to CursorXb
	ld (_CursorXb), a			;
	pop af


	sub $20						;Removes all of the unprintable characters from a
	jr nz, _PrintBChar			;Don't print a space

	ld hl, _CursorX				;Increase cursor x by one to insert a space
	inc (hl)					;
	ret							;Return after printing space

_PrintBChar:
	
	dec a						;Offset the table by 1
	
	;Add a*2 to hl to get the correct location in the jump table
	sla a						;Double a register
	ld c, a						;Put A in BC
	ld b, 0						;
	add hl, bc					;Add BC to HL, result is the address in the jump table in HL

	ld b, (hl)					;Load the jump address into bc with the correct endianness TODO: confirm endianness
	inc hl						;
	ld c, (hl)					;
	
	push bc						;Transfer bc to hl
	pop hl						;

_PrintBLoop:

	call _DrawSprite			;Draw the sprite
	inc hl						;Go to the next sprite
	dec d						;Go to the next horizontal sprite
	jr z, _PrintBNextLine		;Go to the next line if necessary

	push hl						;Go to the next horizontal position
	ld hl, _CursorX				;
	inc (hl)					;
	pop hl						;

	jr _PrintBLoop

_PrintBNextLine:
	push hl

	ld hl, (_CurFont)			;Set HL to the current font address
	ld a, (hl)					;The first byte of the font is the font size (bit 0-3=height, bit 4-7=width)
	ld d, %11110000				;Get the sprite width
	and d						;
	srl a						;Shift the width into place
	srl a
	srl a
	srl a
	ld d, a						;Sprite width in d

	ld hl, _CursorY				;Go to the next vertical line
	inc (hl)					;

	ld a, (_CursorXb)			;Reset the x of the cursor to the original position
	ld (_CursorX), a

	dec e						;Go to the next vertical sprite
	pop hl
	ret z						;If the last line is reached return

	jr _PrintBLoop


;TODO: Next character routine

;--------------------------------

_WriteVRAM:						;[a,bc,d,hl]Copy entirety of VRAM onto the display module	TODO: Change so the display orientation is fixed
.echo "WriteVRAM ",_WriteVRAM;Address of the subroutine
	;hl	= VRAM address counter
	;a	= Display data / command pins
	;b	= Page address counter
	;c	= Column address counter
	;d	= Display half + D/I command pins

	ld hl, _VRAM
	ld bc, $077f				;07 into b, 7f into c

_WriteVRAMLoop:
	ld d, 0						;Clear d

	;Display half selection
	bit 6, c					;Test for display half
	jr z, _WriteVRAMLeftHalf
	set 1, d					;Set CS2 for the right half of the display
	jr _WriteVRAMRightHalf		;TODO: test this hack if it works
	;.db %11001010				;TODO:jp z,xxxx	Because this condition will never be met it will skip over the next 2 bytes, containing the next instruction.
_WriteVRAMLeftHalf:
	set 0, d					;Set CS1 for the left half of the display
_WriteVRAMRightHalf:

	;Writing page address
	ld a, %10111000				;Command for setting the page address register
	or b						;Add page address to a
	call _WriteDisplay

	;Writing column address
	ld a, %01000000				;Command for setting the column address register
	or c						;Bit 6 doesn't need to be masked
	call _WriteDisplay

	;Copy data to display
	set 4, d					;Set D/I pin to data
	ld a, (hl)					;Copy display data to a
	call _WriteDisplay

	;Move to next position
	inc hl
	dec b
	jp m, _WriteVRAMColumnDec	;If b is <0 go to the next line, jr can't check for S flag
	jr _WriteVRAMLoop

_WriteVRAMColumnDec:
	ld b, $07
	dec c
	jp p, _WriteVRAMLoop		;Loop if c is >=0, else end the subroutine. jr can't check for S flag

	ret



_WriteDisplay:
.echo "WriteDisplay ",_WriteDisplay;Address of the subroutine
	;a	= Display data / command pins
	;d	= Display half + D/I command pins

	out (_Display), a
	ld a, %00100100				;Reset, enable and write pins
	or d						;Combine with display half + D/I pins
	out (_DisplayCmd), a
	res 5, a					;Disable enable pin to trigger falling edge
	nop
	nop
	nop
	out (_DisplayCmd), a		;Write disabled enable pin

	ret



;--------------------------------
;VRAM Operations

_ClearDisp:							;[a,bc,de,hl]Clear VRAM					;TODO: Remove: registers affected: a, hl, bc, de
.echo "ClearDisp ",_ClearDisp;Address of the subroutine
	;bc	= Address counter
	;hl	= Size counter
	;a	= 0
	;de	= 1

	ld bc, _VRAM
	ld hl, _VRAMSize
	ld de, 1						;Used for decreasing hl
	xor a							;Faster than ld a, 0 and resets C flag
_ClearDispLoop:						;Don't call
	ld (bc), a						;Put 0 in the current address
	inc bc							;Go to the next address
	sbc hl,de						;Decrease hl
	jr nz, _ClearDispLoop			;Loop until hl is 0

	ret


	
_GetDisplayPosition:				;[hl,nz]Returns the current address the VRAM should be written to and the half of the byte to be written to (alters a)
.echo "GetDisplayPosition ",_GetDisplayPosition;Address of the subroutine
	;Affected registers: af, bc
	push af							;Save registers on the stack so they are not affected in the parent subroutine
	push bc							;

	ld hl, _VRAM					;Initial vram position

	;Add x offset
	ld a, (_CursorX)				;Load x cursor value
	srl a							;Remove the byte half bit
	ld c, a							;Load a into bc
	ld b, 0							;
	add hl, bc						;Add the x value onto hl

	;Add y offset
	ld a, (_CursorY)				;Load y cursor value
	ld c, a
	xor a							;Set a to 0
	sla c
	sla c
	sla c							;Multiplied by 8

	sla c							;Multiply by 4
	sla c							;
	adc a, 0						;Carry if needed

	ld b, a							;Put the carry into b to form bc
	add hl, bc						;Add the y value onto hl
	
	pop bc							;Retrieve registers from the stack
	pop af							;

	push hl							;Set the zero flag according to which half of the byte if positioned
	ld hl, _CursorX					;
	bit 0, (hl)						;TODO: maybe remove this (redundant)
	pop hl							;

	ret


_DrawSprite:						;(hl)Print a 4x4 sprite to VRAM at the cursor position
.echo "DrawSprite ",_DrawSprite;Address of the subroutine
	;Affected registers: af, bc, de, hl
	push af							;Save registers on the stack so they are not affected in the parent subroutine
	push bc							;
	push de							;
	push hl							;
	
	xor a							;Set a to 0
	ld (_DrawCount), a				;Set the draw counter to 0

	;Load sprite
	ld b, (hl)						;Load top half of sprite in b
	inc hl							;Go to the next half of the sprite
	ld c, (hl)						;Load bottom half of sprite in c

	call _GetDisplayPosition		;Get the display position in hl


_DrawSpriteByte:					;Don't call
	;Print half of byte
	ld a, b							;Load the current part of the sprite
	ld d, %11110000					;Mask for the first line of the sprite
	and d							;Mask the first line

	push hl
	ld hl, _CursorX
	bit 0, (hl)
	pop hl

	jr z, _DrawSpriteSkipShift		;Don't shift the byte if it's on the left half

	srl a							;Shift a to the right half of the byte
	srl a							;
	srl a							;
	srl a							;

_DrawSpriteSkipShift:				;Don't call

	;ld e, (hl)						;Get the current byte from VRAM
	;or e							;Combine the current data with the new data
	ld (hl), a						;Put combined data into VRAM

	ld de, $0008					;Add 8 bytes to go to the next line
	add hl, de						;Go to the next line

	ld a, (_DrawCount)				;Check the draw counter for what to do next
	inc a
	ld (_DrawCount), a				;Store the draw counter

	cp 2							;Check if the next byte has been reached
	jr z, _DrawSpriteNextByte

	cp 4							;Check if the routine is over
	jr z, _DrawSpriteDone

	sla b							;Shift the second half of the byte into position
	sla b							;
	sla b							;
	sla b							;

	jr _DrawSpriteByte

_DrawSpriteNextByte:				;Don't call
	ld b, c							;Next byte is c
	jr _DrawSpriteByte

_DrawSpriteDone:					;Don't call
	pop hl							;Retrieve registers from the stack
	pop de							;
	pop bc							;
	pop af							;
	ret



;--------------------------------

;--------------------------------
;Display On/Off

_DisplayInit:						;[a]Properly set all pins to start using the display module, also resets sprite cursor to 0,0
.echo "DisplayInit ",_DisplayInit;Address of the subroutine
	;a	= Pins for display control / resetting sprite cursor position

	;Set reset pin on the display module
	ld a, %00000100
	out (_DisplayCmd), a

	;Reset cursor to 0,0
	xor a							;More efficient than ld a, 0
	ld (_CursorX), a
	ld (_CursorY), a

	ret



_DisplayOn:							;[a]Turn the display on
.echo "DisplayOn ",_DisplayOn;Address of the subroutine
	;a	= Display command

	ld a, %00111111					;Display On command
	jr _DisplayOnOff
	
_DisplayOff:						;[a]Turn the display off
.echo "DisplayOff ",_DisplayOff;Address of the subroutine
	;a	= Display command

	ld a, %00111110					;Display Off command
	;jr _DisplayOnOff				;No need to jump to _DisplayOnOff since it is right under this subroutine

_DisplayOnOff:						;Use DisplayOn/DisplayOff instead
	;a	= Display data / control pins
	
	;Output command
	out (_Display), a

	;Pulse enable pin to send command to display
	ld a, %00100111					;Control signals
	out (_DisplayCmd), a
	nop
	nop
	nop
	ld a, %00000111					;Reset control signals
	out (_DisplayCmd), a

	ret



;--------------------------------

;--------------------------------
;Extra data

.echo ""
__CodeSize:							;Used to indicate code size during assembly

#include "inc/fontSmall.inc"		;Character table

.echo ""
.echo "Size of script in bytes: ",__CodeSize
__FileSize:							;Used to indicate total file size during assembly
.echo "Total file size in bytes: ",__FileSize

;--------------------------------